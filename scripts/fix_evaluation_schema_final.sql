-- Fix Evaluation Center Schema & Permissions
-- RUN THIS IN SUPABASE SQL EDITOR

-- 1. Create Evaluation Tests Catalog (if not exists)
CREATE TABLE IF NOT EXISTS public.evaluation_tests (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title TEXT NOT NULL,
    description TEXT,
    type TEXT NOT NULL CHECK (type IN ('psychometric', 'cognitive', 'language')),
    time_limit_minutes INTEGER,
    config JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
ALTER TABLE public.evaluation_tests ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public read evaluation_tests" ON public.evaluation_tests FOR SELECT USING (true);

-- Seed defaults
INSERT INTO public.evaluation_tests (title, description, type, time_limit_minutes)
SELECT 'Perfil Conductual (Big 5)', 'Descubre tus fortalezas laborales.', 'psychometric', 15
WHERE NOT EXISTS (SELECT 1 FROM public.evaluation_tests WHERE type = 'psychometric');

INSERT INTO public.evaluation_tests (title, description, type, time_limit_minutes)
SELECT 'Habilidades Cognitivas', 'Evalúa tu razonamiento lógico.', 'cognitive', 20
WHERE NOT EXISTS (SELECT 1 FROM public.evaluation_tests WHERE type = 'cognitive');

INSERT INTO public.evaluation_tests (title, description, type, time_limit_minutes)
SELECT 'Evaluación de Idiomas', 'Certifica tu nivel de inglés.', 'language', 15
WHERE NOT EXISTS (SELECT 1 FROM public.evaluation_tests WHERE type = 'language');


-- 2. Create Candidate Results (for Dashboard UI)
CREATE TABLE IF NOT EXISTS public.candidate_results (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    candidate_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    test_id BIGINT REFERENCES public.evaluation_tests(id) ON DELETE CASCADE NOT NULL,
    status TEXT DEFAULT 'started', -- 'started', 'completed'
    score INTEGER DEFAULT 0,
    details JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(candidate_id, test_id)
);
ALTER TABLE public.candidate_results ENABLE ROW LEVEL SECURITY;

-- Fix RLS for candidate_results
DROP POLICY IF EXISTS "Users can view own results" ON public.candidate_results;
CREATE POLICY "Users can view own results" ON public.candidate_results FOR SELECT USING (auth.uid() = candidate_id);

DROP POLICY IF EXISTS "Users can insert own results" ON public.candidate_results;
CREATE POLICY "Users can insert own results" ON public.candidate_results FOR INSERT WITH CHECK (auth.uid() = candidate_id);

DROP POLICY IF EXISTS "Users can update own results" ON public.candidate_results;
CREATE POLICY "Users can update own results" ON public.candidate_results FOR UPDATE USING (auth.uid() = candidate_id);


-- 3. Create Backend Tables (Sessions & Profiles)
CREATE TABLE IF NOT EXISTS public.test_sessions (
    id SERIAL PRIMARY KEY,
    candidate_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    start_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    end_time TIMESTAMP WITH TIME ZONE,
    status TEXT DEFAULT 'in_progress',
    current_theta JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
ALTER TABLE public.test_sessions ENABLE ROW LEVEL SECURITY;

CREATE TABLE IF NOT EXISTS public.candidate_profiles (
    id SERIAL PRIMARY KEY,
    candidate_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    session_id INTEGER REFERENCES public.test_sessions(id),
    scores JSONB NOT NULL,
    validity_flags JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
ALTER TABLE public.candidate_profiles ENABLE ROW LEVEL SECURITY;

CREATE TABLE IF NOT EXISTS public.psych_items (
    id SERIAL PRIMARY KEY,
    text TEXT NOT NULL,
    trait TEXT NOT NULL,
    keyed TEXT DEFAULT 'plus',
    difficulty FLOAT DEFAULT 0.0,
    discrimination FLOAT DEFAULT 1.0,
    is_validity_check BOOLEAN DEFAULT FALSE,
    validity_type TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
ALTER TABLE public.psych_items ENABLE ROW LEVEL SECURITY;

CREATE TABLE IF NOT EXISTS public.item_responses (
    id SERIAL PRIMARY KEY,
    session_id INTEGER REFERENCES public.test_sessions(id) ON DELETE CASCADE,
    item_id INTEGER REFERENCES public.psych_items(id),
    response_value INTEGER,
    response_time_ms INTEGER,
    mouse_trajectory_entropy FLOAT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
ALTER TABLE public.item_responses ENABLE ROW LEVEL SECURITY;


-- 4. RLS for Backend Tables
CREATE POLICY "Public read psych_items" ON public.psych_items FOR SELECT USING (true);

CREATE POLICY "Users manage own sessions" ON public.test_sessions 
    USING (auth.uid() = candidate_id) WITH CHECK (auth.uid() = candidate_id);

CREATE POLICY "Users manage own responses" ON public.item_responses 
    USING (EXISTS (SELECT 1 FROM public.test_sessions s WHERE s.id = session_id AND s.candidate_id = auth.uid()))
    WITH CHECK (EXISTS (SELECT 1 FROM public.test_sessions s WHERE s.id = session_id AND s.candidate_id = auth.uid()));

CREATE POLICY "Users read own profiles" ON public.candidate_profiles 
    USING (auth.uid() = candidate_id);

CREATE POLICY "Users can insert own profiles" ON public.candidate_profiles 
    FOR INSERT WITH CHECK (auth.uid() = candidate_id);
    
-- Allow Service Role (Backend) full access implies using service_role key, or we can add specific policies if backend user behaves as authenticated user.
-- For now, assuming backend uses SERVICE_ROLE KEY which bypasses RLS.


-- 5. Auto-Sync Trigger: Update candidate_results when test_sessions completes
CREATE OR REPLACE FUNCTION sync_session_to_results()
RETURNS TRIGGER AS $$
DECLARE
    v_test_id BIGINT;
BEGIN
    -- Determine test_id. For demo, we assume:
    -- 1 = Psychometric (mapped to session logic usually, but here simplifed)
    -- We'll assume all sessions via TestRunner are Psychometric (ID 1) for now, 
    -- or we need a way to link session to test type.
    -- Defaulting to 1 (Psychometric) as it's the main flow.
    v_test_id := 1; 

    IF NEW.status = 'completed' THEN
        INSERT INTO public.candidate_results (candidate_id, test_id, status, updated_at)
        VALUES (NEW.candidate_id, v_test_id, 'completed', NOW())
        ON CONFLICT (candidate_id, test_id) 
        DO UPDATE SET status = 'completed', updated_at = NOW();
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS on_session_complete ON public.test_sessions;
CREATE TRIGGER on_session_complete
AFTER UPDATE ON public.test_sessions
FOR EACH ROW
WHEN (OLD.status IS DISTINCT FROM NEW.status AND NEW.status = 'completed')
EXECUTE PROCEDURE sync_session_to_results();


-- 6. Seed Psych Items (Big 5)
INSERT INTO public.psych_items (text, trait, keyed)
SELECT 'Suelo tomar la iniciativa en situaciones grupales.', 'Extraversion', 'plus'
WHERE NOT EXISTS (SELECT 1 FROM public.psych_items WHERE text LIKE 'Suelo tomar%');

INSERT INTO public.psych_items (text, trait, keyed)
SELECT 'Me siento cómodo siendo el centro de atención.', 'Extraversion', 'plus'
WHERE NOT EXISTS (SELECT 1 FROM public.psych_items WHERE text LIKE 'Me siento%');

INSERT INTO public.psych_items (text, trait, keyed)
SELECT 'Presto atención a los detalles más pequeños.', 'Conscientiousness', 'plus'
WHERE NOT EXISTS (SELECT 1 FROM public.psych_items WHERE text LIKE 'Presto atención%');

INSERT INTO public.psych_items (text, trait, keyed)
SELECT 'Me estreso con facilidad ante cambios repentinos.', 'Neuroticism', 'plus'
WHERE NOT EXISTS (SELECT 1 FROM public.psych_items WHERE text LIKE 'Me estreso%');

INSERT INTO public.psych_items (text, trait, keyed)
SELECT 'Tengo una imaginación muy viva.', 'Openness', 'plus'
WHERE NOT EXISTS (SELECT 1 FROM public.psych_items WHERE text LIKE 'Tengo una%');

INSERT INTO public.psych_items (text, trait, keyed)
SELECT 'Me intereso por los problemas de los demás.', 'Agreeableness', 'plus'
WHERE NOT EXISTS (SELECT 1 FROM public.psych_items WHERE text LIKE 'Me intereso%');

